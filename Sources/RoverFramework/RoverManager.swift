import Flynn
import Foundation
import Hitch

public typealias kDidConnectCallback = (RoverManager) -> ()

public class RoverManager: Actor {
    
    private var rovers: [Rover] = []
    private var roundRobin = 0

    public init(connect info: ConnectionInfo,
                maxConnections: Int,
                _ sender: Actor,
                _ onFirstConnect: @escaping kDidConnectCallback) {
        
        super.init()
        
        var didCallFirstConnect = false
        for _ in 0..<maxConnections {
            let rover = Rover()
            rovers.append(rover)
            rover.beConnect(info, self) { success in
                if didCallFirstConnect == false && success == true {
                    sender.unsafeSend {
                        onFirstConnect(self)
                    }
                    didCallFirstConnect = true
                }
            }
        }
    }

    private func _beNext() -> Rover? {
        // round robin the next connection
        roundRobin = (roundRobin + 1) % rovers.count
        // if the next one happens to have more oustanding requests than its neighbor, skip it and choose the neighbor
        let neighbor = (roundRobin + 1) % rovers.count
        if rovers[roundRobin].unsafeMessagesCount > rovers[neighbor].unsafeMessagesCount {
            roundRobin = neighbor
        }
        return rovers[roundRobin]
    }

    private func _beRun(_ statement: String,
                        _ returnCallback: @escaping (Result) -> Void) {
        guard let rover = _beNext() else { fatalError("beRun() called before any connections were established") }
        rover.beRun(statement, self) { result in
            returnCallback(result)
        }
    }

    private func _beRun(_ statement: String,
                        _ params: [Any?],
                        _ returnCallback: @escaping (Result) -> Void) {
        guard let rover = _beNext() else { fatalError("beRun() called before any connections were established") }
        rover.beRun(statement, params, self) { result in
            returnCallback(result)
        }
    }
    
    private func _beRun(_ statement: Hitch,
                        _ returnCallback: @escaping (Result) -> Void) {
        guard let rover = _beNext() else { fatalError("beRun() called before any connections were established") }
        rover.beRun(statement, self) { result in
            returnCallback(result)
        }
    }

    private func _beRun(_ statement: Hitch,
                        _ params: [Any?],
                        _ returnCallback: @escaping (Result) -> Void) {
        guard let rover = _beNext() else { fatalError("beRun() called before any connections were established") }
        rover.beRun(statement, params, self) { result in
            returnCallback(result)
        }
    }

}

// MARK: - Autogenerated by FlynnLint
// Contents of file after this marker will be overwritten as needed

extension RoverManager {

    @discardableResult
    public func beNext(_ sender: Actor,
                       _ callback: @escaping ((Rover?) -> Void)) -> Self {
        unsafeSend {
            let result = self._beNext()
            sender.unsafeSend { callback(result) }
        }
        return self
    }
    @discardableResult
    public func beRun(_ statement: String,
                      _ sender: Actor,
                      _ callback: @escaping ((Result) -> Void)) -> Self {
        unsafeSend {
            self._beRun(statement) { arg0 in
                sender.unsafeSend {
                    callback(arg0)
                }
            }
        }
        return self
    }
    @discardableResult
    public func beRun(_ statement: String,
                      _ params: [Any?],
                      _ sender: Actor,
                      _ callback: @escaping ((Result) -> Void)) -> Self {
        unsafeSend {
            self._beRun(statement, params) { arg0 in
                sender.unsafeSend {
                    callback(arg0)
                }
            }
        }
        return self
    }
    @discardableResult
    public func beRun(_ statement: Hitch,
                      _ sender: Actor,
                      _ callback: @escaping ((Result) -> Void)) -> Self {
        unsafeSend {
            self._beRun(statement) { arg0 in
                sender.unsafeSend {
                    callback(arg0)
                }
            }
        }
        return self
    }
    @discardableResult
    public func beRun(_ statement: Hitch,
                      _ params: [Any?],
                      _ sender: Actor,
                      _ callback: @escaping ((Result) -> Void)) -> Self {
        unsafeSend {
            self._beRun(statement, params) { arg0 in
                sender.unsafeSend {
                    callback(arg0)
                }
            }
        }
        return self
    }

}
